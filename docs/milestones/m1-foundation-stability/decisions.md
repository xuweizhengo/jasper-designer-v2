# M1: Foundation Stability - 技术决策记录

## 决策记录格式

每个决策使用以下格式记录:
- **决策ID**: D1.x (M1的第x个决策)
- **日期**: YYYY-MM-DD
- **决策者**: 角色/姓名
- **状态**: 提议/已接受/已实施/已废弃
- **背景**: 为什么需要做这个决策
- **决策**: 具体的决策内容
- **后果**: 决策的影响和预期结果
- **替代方案**: 考虑过的其他选择

---

## D1.1 TypeScript错误修复策略

**日期**: 2025-08-05  
**决策者**: 开发团队  
**状态**: 已接受  

**背景**: 
当前项目有12个TypeScript错误阻塞构建，主要集中在SVG组件类型和ElementContent类型定义上。需要选择修复策略。

**决策**: 
采用渐进式修复策略，优先修复阻塞构建的错误，保持最小变更原则。

**具体方案**:
1. 移除SVG不支持的属性 (width/height在text元素上)
2. 为ElementContent添加discriminated union的type字段
3. 清理未使用的变量和导入
4. 不进行大规模重构

**后果**:
- ✅ 风险可控，变更范围小
- ✅ 可以快速解除构建阻塞
- ⚠️ 可能需要在后续milestone中进一步优化类型设计

**替代方案**:
- 方案A: 大规模重构组件类型系统 (风险高，时间长)
- 方案B: 使用any类型绕过错误 (不符合项目质量目标)

---

## D1.2 SVG组件属性处理方式

**日期**: 2025-08-05  
**决策者**: 前端团队  
**状态**: 已接受  

**背景**:
Solid.js的SVG类型定义严格遵循DOM标准，text元素不支持width/height属性，但我们的组件设计中使用了这些属性进行布局控制。

**决策**:
移除SVG text元素上的width/height属性，改用其他方式控制文字布局。

**具体实施**:
```typescript
// 修改前
<text width={size.width} height={size.height}>

// 修改后  
<text>
```

**后果**:
- ✅ 符合SVG标准和TypeScript类型检查
- ✅ 避免了类型错误
- ⚠️ 需要重新设计文字元素的布局控制逻辑

**替代方案**:
- 方案A: 自定义SVG类型定义覆盖默认类型 (维护成本高)
- 方案B: 使用foreignObject包装HTML元素 (复杂度增加)

---

## D1.3 ElementContent类型设计

**日期**: 2025-08-05  
**决策者**: 架构团队  
**状态**: 已接受  

**背景**:
组件库的create_content函数返回的对象缺少type字段，导致与ElementContent联合类型不匹配。

**决策**:
为所有ElementContent类型添加discriminated union标记，确保类型安全。

**具体实施**:
```typescript
// 修改前
create_content: () => ({
  content: '文字内容',
  style: { ... }
})

// 修改后
create_content: () => ({
  type: 'Text',  // 添加判别字段
  content: '文字内容', 
  style: { ... }
})
```

**后果**:
- ✅ 类型安全得到保证
- ✅ 支持编译时类型检查
- ✅ 便于运行时类型判断
- ⚠️ 需要更新所有组件定义

**替代方案**:
- 方案A: 使用可选的type字段 (类型检查不够严格)
- 方案B: 分别定义不同的内容类型 (代码重复)

---

## D1.4 构建工具链配置

**日期**: 2025-08-05  
**决策者**: 开发团队  
**状态**: 提议中  

**背景**:
需要建立完善的代码质量检查工具链，包括ESLint、Prettier、以及pre-commit hooks。

**决策** (待确认):
采用业界标准的工具配置，启用严格的代码质量检查。

**具体配置**:
- ESLint: @typescript-eslint/recommended + solid相关规则
- Prettier: 2空格缩进，单引号，尾随逗号
- Pre-commit: 运行lint和格式化检查

**后果**:
- ✅ 代码质量得到保证
- ✅ 团队代码风格统一
- ⚠️ 可能需要修复大量现有代码格式问题

**替代方案**:
- 方案A: 使用更宽松的检查规则 (质量标准降低)
- 方案B: 仅使用TypeScript编译器检查 (功能不够完整)

---

## D1.5 测试策略选择

**日期**: 2025-08-05  
**决策者**: 质量团队  
**状态**: 提议中  

**背景**:
需要为项目建立基础的测试覆盖，选择合适的测试框架和策略。

**决策** (待确认):
前端使用Vitest + @solidjs/testing-library，后端使用Rust内置测试框架。

**理由**:
- Vitest与Vite构建工具集成良好
- @solidjs/testing-library专门为Solid.js设计
- Rust内置测试功能强大且无需额外依赖

**后果**:
- ✅ 测试工具链简单可靠
- ✅ 与现有技术栈集成良好
- ⚠️ 需要学习新的测试API

**替代方案**:
- 方案A: 使用Jest (配置复杂，与Vite集成困难)
- 方案B: 暂时不添加测试 (不符合质量目标)

---

## 决策执行状态

| 决策ID | 决策内容 | 状态 | 执行者 | 完成度 |
|--------|----------|------|--------|--------|
| D1.1 | TypeScript错误修复策略 | 已接受 | 开发团队 | 0% |
| D1.2 | SVG组件属性处理 | 已接受 | 前端团队 | 0% |
| D1.3 | ElementContent类型设计 | 已接受 | 架构团队 | 0% |
| D1.4 | 构建工具链配置 | 提议中 | 开发团队 | 0% |
| D1.5 | 测试策略选择 | 提议中 | 质量团队 | 0% |

---

## 决策审查

**下次审查日期**: 2025-08-06  
**审查重点**: 
1. D1.1-D1.3的执行效果
2. D1.4-D1.5的最终确认
3. 新出现的技术决策需求

**审查参与者**: 架构团队、开发团队、质量团队

---

## 经验教训

### 已学到的经验
1. **类型安全投资**: 早期投入类型安全设计，避免后期大规模重构
2. **工具选择**: 选择与主要技术栈集成良好的工具，减少配置复杂度

### 待验证的假设
1. 渐进式修复策略是否能有效控制风险
2. 选择的类型设计是否能满足后续开发需求